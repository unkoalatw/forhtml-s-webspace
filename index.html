// ===== 防頂號系統 Google Apps Script 後端 (Firebase 版) =====
// 資料庫：Firebase Realtime Database
// 功能：登入/註冊 + 上線/下線 + 好友 + FCM 推播

const PROJECT_ID = 'antikick-a0da3'; // 您的 Project ID
const DATABASE_URL = 'https://antikick-a0da3-default-rtdb.firebaseio.com'; // 標準 RTDB URL

// ===== Web App 入口 =====
function doGet(e) { return handleRequest(e); }
function doPost(e) { return handleRequest(e); }

function handleRequest(e) {
  const params = (e && e.parameter) ? e.parameter : {};
  let body = {};
  
  try {
    if (params.data) {
      body = JSON.parse(decodeURIComponent(params.data));
    } else if (e && e.postData && e.postData.contents) {
      body = JSON.parse(e.postData.contents);
    }
  } catch (err) {
    return respond({ success: false, message: '解析錯誤' }, params.callback);
  }
  
  const action = body.action;
  let result = { success: false, message: '未知操作' };
  
  try {
    switch (action) {
      case 'register':
        result = register(body.email, body.password);
        break;
      case 'login':
        result = login(body.email, body.password);
        break;
      case 'getStatus':
        result = getStatus(body.token);
        break;
      case 'goOnline':
        result = goOnline(body.token);
        break;
      case 'goOffline':
        result = goOffline(body.token);
        break;
      case 'sendUrgent':
        result = sendUrgent(body.token);
        break;
      case 'declineUrgent':
        result = declineUrgent(body.token);
        break;
      case 'addFriend':
        result = addFriend(body.token, body.friendCode);
        break;
      case 'removeFriend':
        result = removeFriend(body.token, body.friendId);
        break;
      case 'updateFcm':
        result = updateFcm(body.token, body.fcmToken);
        break;
      case 'firebaseLogin': // 新增：處理 Firebase 原生登入
        result = handleFirebaseLogin(body.uid, body.email, body.fcmToken, body.isAnonymous);
        break;
      case 'ping':
        result = { success: true, message: 'pong' };
        break;
      default:
        result = { success: false, message: '未知操作: ' + action };
    }
  } catch (err) {
    result = { success: false, message: '錯誤: ' + err.toString() };
    Logger.log(err);
  }
  
  return respond(result, params.callback);
}

function respond(result, callback) {
  const json = JSON.stringify(result);
  
  // JSONP Mode
  if (callback) {
    return ContentService.createTextOutput(callback + '(' + json + ');')
      .setMimeType(ContentService.MimeType.JAVASCRIPT);
  }
  
  // CORS Mode (JSON)
  return ContentService.createTextOutput(json)
    .setMimeType(ContentService.MimeType.JSON);
}

// 必須讓 doPost 回傳正確的 JSON 並不被 Google 錯誤頁面攔截
// Google Apps Script 的 doPost 其實很難完美支援 CORS preflight，
// 但我們可以透過單純的 fetch + no-cors 來觸發寫入，或者依靠 Google 的 redirect 機制。
// 不過，最穩定的方式還是 TextOutput。


// ===== Firebase 工具函數 (REST API) =====
function getFirebaseToken() {
  return ScriptApp.getOAuthToken();
}

function fbRead(path) {
  const url = `${DATABASE_URL}${path}.json`;
  const options = {
    method: 'get',
    headers: { Authorization: 'Bearer ' + getFirebaseToken() },
    muteHttpExceptions: true
  };
  const res = UrlFetchApp.fetch(url, options);
  if (res.getResponseCode() === 200) {
    return JSON.parse(res.getContentText());
  }
  return null;
}

function fbWrite(path, data) {
  const url = `${DATABASE_URL}${path}.json`;
  const options = {
    method: 'put',
    contentType: 'application/json',
    headers: { Authorization: 'Bearer ' + getFirebaseToken() },
    payload: JSON.stringify(data),
    muteHttpExceptions: true
  };
  return UrlFetchApp.fetch(url, options);
}

function fbUpdate(path, data) {
  const url = `${DATABASE_URL}${path}.json`;
  const options = {
    method: 'patch',
    contentType: 'application/json',
    headers: { Authorization: 'Bearer ' + getFirebaseToken() },
    payload: JSON.stringify(data),
    muteHttpExceptions: true
  };
  return UrlFetchApp.fetch(url, options);
}

function fbPush(path, data) {
  const url = `${DATABASE_URL}${path}.json`;
  const options = {
    method: 'post',
    contentType: 'application/json',
    headers: { Authorization: 'Bearer ' + getFirebaseToken() },
    payload: JSON.stringify(data),
    muteHttpExceptions: true
  };
  return JSON.parse(UrlFetchApp.fetch(url, options).getContentText()); // returns {name: "id"}
}

function fbDelete(path) {
  const url = `${DATABASE_URL}${path}.json`;
  const options = {
    method: 'delete',
    headers: { Authorization: 'Bearer ' + getFirebaseToken() },
    muteHttpExceptions: true
  };
  return UrlFetchApp.fetch(url, options);
}

// ===== 輔助函數 =====
function generateId() { return Utilities.getUuid(); }
function generateToken() { return Utilities.getUuid() + '-' + Date.now(); }
function hashPassword(password) {
  const hash = Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, password);
  return hash.map(b => ('0' + (b & 0xFF).toString(16)).slice(-2)).join('');
}
function encodeEmail(email) { return Utilities.base64EncodeWebSafe(email).replace(/=/g, ''); }
function generateCode() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let code = '';
  for (let i = 0; i < 6; i++) code += chars.charAt(Math.floor(Math.random() * chars.length));
  return code;
}

// ===== 核心邏輯 =====

function register(email, password) {
  if (!email || !password) return { success: false, message: '請提供 email 和密碼' };
  
  const encodedEmail = encodeEmail(email);
  const existingId = fbRead(`/email_mapping/${encodedEmail}`);
  if (existingId) return { success: false, message: '此 email 已註冊' };
  
  const id = generateId();
  const friendCode = generateCode();
  const token = generateToken();
  const hashedPw = hashPassword(password);
  
  const newUser = {
    id: id,
    email: email,
    password: hashedPw,
    friendCode: friendCode,
    isOnline: false,
    lastSeen: new Date().toISOString(),
    token: token,
    fcmToken: ''
  };
  
  // 寫入用戶資料 & Email 映射 & Code 映射
  fbWrite(`/users/${id}`, newUser);
  fbWrite(`/email_mapping/${encodedEmail}`, id);
  fbWrite(`/code_mapping/${friendCode}`, id);
  
  return {
    success: true,
    message: '註冊成功',
    user: { id, email, friendCode, isOnline: false },
    token
  };
}

function login(email, password) {
  if (!email || !password) return { success: false, message: '請提供 email 和密碼' };
  
  const encodedEmail = encodeEmail(email);
  const userId = fbRead(`/email_mapping/${encodedEmail}`);
  
  if (!userId) return { success: false, message: '用戶不存在' };
  
  const user = fbRead(`/users/${userId}`);
  if (!user || user.password !== hashPassword(password)) {
    return { success: false, message: '密碼錯誤' };
  }
  
  const newToken = generateToken();
  fbUpdate(`/users/${userId}`, { 
    token: newToken, 
    lastSeen: new Date().toISOString() 
  });
  
  // 如果 status 表裡 token 舊了，其實不需要更新，因為 status 應該存 userId
  
  return { success: true, message: '登入成功', user: { id: user.id, email: user.email, friendCode: user.friendCode, isOnline: user.isOnline }, token: newToken };
}

// 處理 Firebase 原生登入 (Google/匿名)
function handleFirebaseLogin(uid, email, fcmToken, isAnonymous) {
  if (!uid) return { success: false, message: '無效的 UID' };
  
  // 嘗試透過 UID 查找用戶 (我們將 UID 當作 id 使用，或者建立 mapping)
  // 為了簡單，我們直接用 Firebase UID 作為用戶 ID
  
  let user = fbRead(`/users/${uid}`);
  const newToken = generateToken();
  
  if (!user) {
    // 新用戶 -> 自動註冊
    const friendCode = generateCode();
    // 匿名用戶沒有 email，給個假名
    const finalEmail = email || (isAnonymous ? `anon_${friendCode}@antikick.app` : `user_${friendCode}@antikick.app`);
    
    user = {
      id: uid, // 使用 Firebase UID
      email: finalEmail,
      password: '', // 無密碼
      friendCode: friendCode,
      isOnline: false,
      lastSeen: new Date().toISOString(),
      token: newToken,
      fcmToken: fcmToken || '',
      isAnonymous: !!isAnonymous
    };
    
    fbWrite(`/users/${uid}`, user);
    fbWrite(`/code_mapping/${friendCode}`, uid);
    // Email mapping 只有在有 email 時才寫
    if (email) fbWrite(`/email_mapping/${encodeEmail(email)}`, uid);
    
    return { success: true, message: '註冊並登入成功', user: { id: uid, email: finalEmail, friendCode: friendCode }, token: newToken };
  } else {
    // 老用戶 -> 更新 Token
    const updates = { token: newToken, lastSeen: new Date().toISOString() };
    if (fcmToken) updates.fcmToken = fcmToken;
    if (email && !user.email.includes('@antikick.app')) {
       // 如果原本是用 email 註冊的，確保 mapping 存在（雖然 uid 變了... 這是一個整合問題）
       // 如果這是從舊系統遷移來的 email，邏輯會比較複雜。
       // 為了簡單，我們假設這是全新系統，或者 Firebase Auth 是主要來源。
    }
    
    fbUpdate(`/users/${uid}`, updates);
    return { success: true, message: '登入成功', user: { id: uid, email: user.email, friendCode: user.friendCode }, token: newToken };
  }
}

// 根據 Token 查找用戶 (這步需要遍歷? 不，我們建立一個 token 索引會更好。但暫時用簡單方法:
// 為了避免全表掃描，我們在 Login 時可以回傳 ID。
// 為了兼容性，我們建立一個 Token Mapping: /token_mapping/{token} -> userId
// (注意：舊代碼沒有這層，我們在 Login/Register 時加上)

// 修正後的 getUserByToken，解決 UrlFetch URL 參數問題
function getUserByToken(token) {
    if (!token) return null;
    
    // Firebase REST API 要求字串值查詢要加上引號
    // 例如 equalTo="myToken"
    // 在 URL 中這必須被編碼，變成 equalTo=%22myToken%22
    
    // 我們先構建基礎 URL
    const baseUrl = `${DATABASE_URL}/users.json`;
    
    // 正確編碼參數
    // 1. orderBy="token" -> orderBy=%22token%22
    // 2. equalTo="VALUE" -> equalTo=%22VALUE%22
    
    const tokenEncoded = encodeURIComponent(token);
    const query = `?orderBy=%22token%22&equalTo=%22${tokenEncoded}%22&limitToFirst=1`;
    
    const url = baseUrl + query;
    
    const options = { 
      headers: { Authorization: 'Bearer ' + getFirebaseToken() },
      muteHttpExceptions: true
    };
    
    try {
      const res = UrlFetchApp.fetch(url, options);
      if (res.getResponseCode() !== 200) {
        Logger.log('Firebase Error (' + res.getResponseCode() + '): ' + res.getContentText());
        return null;
      }
      
      const data = JSON.parse(res.getContentText());
      const keys = Object.keys(data || {});
      if (keys.length > 0) return data[keys[0]];
    } catch (e) {
      Logger.log('getUserByToken Error: ' + e);
      // 如果還是失敗，可能是 token 包含極端特殊字符，這時候只能放棄查詢
    }
    return null;
}

function updateFcm(token, fcmToken) {
  const user = getUserByToken(token);
  if (!user) return { success: false, message: '請重新登入' };
  
  fbUpdate(`/users/${user.id}`, { fcmToken: fcmToken });
  return { success: true, message: 'Token 更新成功' };
}

function getStatus(token) {
  const user = getUserByToken(token);
  if (!user) return { success: false, message: '請重新登入' };
  
  // 更新最後上線時間
  fbUpdate(`/users/${user.id}`, { lastSeen: new Date().toISOString() });
  
  // 獲取全局狀態
  const status = fbRead(`/status`) || { currentUser: '', urgentFrom: '' };
  
  // 獲取好友
  const friendsMap = fbRead(`/users/${user.id}/friends`) || {};
  const friends = [];
  for (const fId in friendsMap) {
    const fData = fbRead(`/users/${fId}`);
    if (fData) {
      friends.push({ id: fData.id, email: fData.email, friendCode: fData.friendCode });
    }
  }
  
  let urgentRequest = null;
  if (status.urgentFrom && status.currentUser === user.id) {
    urgentRequest = { from: status.urgentFrom };
  }
  
  // 獲取 Current User Email 用於顯示
  let currentEmail = '';
  if (status.currentUser) {
    const u = fbRead(`/users/${status.currentUser}`);
    if (u) currentEmail = u.email;
  }
  
  return {
    success: true,
    inUse: !!status.currentUser,
    currentUser: currentEmail ? currentEmail.split('@')[0].toUpperCase() : '',
    currentUserId: status.currentUser,
    onlineUsers: 1, // 暫時難以計算精確的在線人數，除非維護一個 online 列表
    urgentRequest,
    user: { id: user.id, email: user.email, friendCode: user.friendCode },
    friends
  };
}

function goOnline(token) {
  const user = getUserByToken(token);
  if (!user) return { success: false, message: '請重新登入' };
  
  const status = fbRead(`/status`) || {};
  
  if (status.currentUser && status.currentUser !== user.id) {
    return { success: false, message: '帳號正在被使用中' };
  }
  
  fbUpdate(`/status`, { 
    currentUser: user.id, 
    startTime: new Date().toISOString(),
    urgentFrom: '',
    urgentTime: ''
  });
  
  return { success: true, message: '已上線' };
}

function goOffline(token) {
  const user = getUserByToken(token);
  if (!user) return { success: false, message: '請重新登入' };
  
  const status = fbRead(`/status`) || {};
  
  if (status.currentUser !== user.id) {
    // 允許強制下線嗎？原本邏輯是不行。
    // 但如果是自己，就是清除
    // return { success: false, message: '你不是當前使用者' };
  }
  
  fbUpdate(`/status`, { 
    currentUser: '', 
    startTime: '',
    urgentFrom: '',
    urgentTime: ''
  });
  
  return { success: true, message: '已下線' };
}

function sendUrgent(token) {
  const user = getUserByToken(token);
  if (!user) return { success: false, message: '請重新登入' };
  
  const status = fbRead(`/status`) || {};
  if (!status.currentUser) return { success: false, message: '帳號目前沒人使用' };
  if (status.currentUser === user.id) return { success: false, message: '你就是當前使用者' };
  
  const userName = user.email.split('@')[0].toUpperCase();
  
  fbUpdate(`/status`, {
    urgentFrom: userName,
    urgentTime: new Date().toISOString()
  });
  
  // FCM 推播
  const targetUser = fbRead(`/users/${status.currentUser}`);
  if (targetUser && targetUser.fcmToken) {
    sendFcmNotification(targetUser.fcmToken, '緊急請求', userName + ' 急需使用帳號');
  }
  
  return { success: true, message: '已發送緊急請求' };
}

function declineUrgent(token) {
  const user = getUserByToken(token);
  if (!user) return { success: false, message: '請重新登入' };
  
  fbUpdate(`/status`, { urgentFrom: '', urgentTime: '' });
  return { success: true, message: '已拒絕' };
}

function addFriend(token, friendCode) {
  const user = getUserByToken(token);
  if (!user) return { success: false, message: '請重新登入' };
  
  const friendId = fbRead(`/code_mapping/${friendCode}`);
  if (!friendId) return { success: false, message: '找不到此好友代碼' };
  if (friendId === user.id) return { success: false, message: '不能加自己' };
  
  // 檢查是否已有
  const friends = fbRead(`/users/${user.id}/friends`) || {};
  if (friends[friendId]) return { success: false, message: '已經是好友了' };
  
  // 雙向綁定
  fbUpdate(`/users/${user.id}/friends`, { [friendId]: true });
  fbUpdate(`/users/${friendId}/friends`, { [user.id]: true });
  
  return { success: true, message: '好友綁定成功' };
}

function removeFriend(token, friendId) {
  const user = getUserByToken(token);
  if (!user) return { success: false, message: '請重新登入' };
  
  fbDelete(`/users/${user.id}/friends/${friendId}`);
  fbDelete(`/users/${friendId}/friends/${user.id}`);
  
  return { success: true, message: '已解除綁定' };
}

// ===== FCM 發送 (V1 API) =====
function sendFcmNotification(token, title, body) {
   if (!token || !PROJECT_ID) return;
   
   const url = 'https://fcm.googleapis.com/v1/projects/' + PROJECT_ID + '/messages:send';
   const payload = {
     message: {
       token: token,
       data: { title: title, body: body, action: 'urgent' },
       android: { priority: 'high' }
     }
   };
   
   const options = {
     method: 'post',
     contentType: 'application/json',
     headers: { Authorization: 'Bearer ' + getFirebaseToken() },
     payload: JSON.stringify(payload),
     muteHttpExceptions: true
   };
   
   try { UrlFetchApp.fetch(url, options); } catch(e) { Logger.log(e); }
}

// ===== 管理員工具 (慎用) =====
// 執行此函數將會清空整個 Firebase Realtime Database
function admin_clearAllData() {
  const result = fbDelete('/'); // 删除根節點下的所有數據
  Logger.log('Database cleared: ' + result);
  return 'Database Cleared';
}
